
<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Luna ‚Äì assistente locale (v1.4a)</title>
<style>
:root{
  --bg1:#0e0f16; --bg2:#151826;
  --surface:#1d2133; --bubble:#232844;
  --text:#e7ecff; --muted:#aab3d9; --accent:#6c84ff; --ok:#44d17c; --warn:#f8c146; --err:#ff6b6b;
}
*{box-sizing:border-box} html,body{height:100%}
body{
  margin:0; color:var(--text); background: radial-gradient(circle at 20% -10%,var(--bg2),var(--bg1));
  font: 16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Calibri,sans-serif;
  display:flex; flex-direction:column; align-items:center;
}
.app{width:100%; max-width:860px; padding:16px 14px 22px}
header{display:flex; align-items:center; justify-content:space-between; gap:12px; margin:4px 0 8px}
h1{margin:0; font-size: clamp(20px,4.8vw,28px); letter-spacing:0.3px}
.badge{display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted)}
.badge .state{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:99px; background: #20253c;}
.state b{font-weight:600}

#settingsBtn{all:unset; display:grid; place-items:center; width:40px; height:40px; border-radius:12px;
  background:var(--surface); cursor:pointer}
#settingsBtn:active{transform:scale(.98)}

.chat{
  background: linear-gradient(180deg,#161a2a 0%, #121628 100%);
  border:1px solid #262b49; border-radius:16px; min-height:58vh; padding:14px; overflow:hidden;
  display:flex; flex-direction:column; gap:10px;
}
.msg{max-width:92%; padding:10px 12px; border-radius:12px; box-shadow:0 1px 0 rgba(0,0,0,.15)}
.me{align-self:flex-end; background:#1f2645}
.ai{align-self:flex-start; background:var(--bubble)}
.msg small{display:block; color:var(--muted); margin-top:6px; font-size:12px}

.footer{
  position:sticky; bottom:0; background:transparent; padding-top:12px
}
.row{display:flex; gap:8px}
input[type=text]{
  flex:1; padding:12px 14px; border-radius:12px; outline:none;
  background:var(--surface); border:1px solid #2a3154; color:var(--text)
}
button.primary{
  border:0; background:var(--accent); color:white; padding:12px 16px; border-radius:12px; font-weight:600; cursor:pointer
}
.iconbtn{border:1px solid #2a3154; background:var(--surface); color:var(--text); border-radius:12px; width:48px; height:48px}
.iconbtn[disabled]{opacity:.55; cursor:not-allowed}

.hint{margin-top:8px; color:var(--muted); font-size:12px}
kbd{background:#2a3154; padding:1px 6px; border-radius:6px}

.micBadge{
  display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:10px; font-size:12px;
  background:#1b2037; border:1px solid #2a3154;
}
.micDot{width:10px; height:10px; border-radius:50%; background:#6572a8}
.micDot.live{background:var(--ok); box-shadow:0 0 0 6px rgba(68,209,124,.15)}
.meter{height:8px; width:72px; background:#20253c; border-radius:6px; overflow:hidden}
.meter > i{display:block; height:100%; width:0%; background:linear-gradient(90deg,#65d17e,#6c84ff)}

#panel{
  position:fixed; inset:auto 0 0 0; transform:translateY(100%); transition:transform .25s;
  background:#0e1120; border-top:1px solid #2a3154; padding:16px; max-height:86vh; overflow:auto
}
#panel.open{transform:none}
.panelTitle{display:flex; align-items:center; justify-content:space-between}
.grid{display:grid; gap:12px; grid-template-columns:1fr}
fieldset{border:1px solid #2a3154; border-radius:12px; padding:12px}
legend{color:var(--muted)}
label{display:block; margin:6px 0 4px}
select,input[type=range],input[type=text].mini{
  width:100%; padding:10px; border-radius:10px; background:#171c30; border:1px solid #2a3154; color:var(--text)
}
.switch{display:flex; align-items:center; gap:8px}
.switch input{transform:scale(1.2)}
.small{color:var(--muted); font-size:12px}
hr.sep{border:0; border-top:1px dashed #2a3154; margin:10px 0}
a.link{color:#9db1ff; text-decoration:none}
.themeRow{display:flex; gap:8px; flex-wrap:wrap}
.themeRow button{border:1px solid #2a3154; background:#171c30; color:var(--text); padding:8px 10px; border-radius:10px}
.themeRow button.active{outline:2px solid var(--accent)}
</style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>üåô <span id="assistantName">Luna</span></h1>
      <div class="badge">
        <span class="state"><b>Stato:</b> <span id="providerState">Locale</span></span>
        <span class="micBadge"><span class="micDot" id="micDot"></span> <span id="micText">Idle</span> <span class="meter"><i id="vu"></i></span></span>
      </div>
    </div>
    <button id="settingsBtn" title="Impostazioni">‚öôÔ∏è</button>
  </header>

  <main class="chat" id="chat" aria-live="polite">
    <div class="msg ai">
      Ciao! Sono <b id="who">Luna</b>. Scrivimi, oppure premi üé§ per parlare. Posso leggere le risposte con üîä.
      <small>Consigli: ‚Äúvoce femminile‚Äù, ‚Äúcambia nome in Aurora‚Äù, ‚Äúapri impostazioni‚Äù.</small>
    </div>
  </main>

  <div class="footer">
    <div class="row">
      <input id="input" type="text" placeholder="Scrivi un messaggio per Luna‚Ä¶" autocomplete="off" />
      <button class="primary" id="sendBtn">Invia</button>
      <button class="iconbtn" id="speakBtn" title="Parla (tieni premuto su iOS se necessario)">üé§</button>
      <button class="iconbtn" id="ttsBtn" title="Leggi l‚Äôultimo messaggio">üîä</button>
    </div>
    <div class="hint">Modalit√†: <b id="modeHint">Testo</b>. Parlo solo quando il microfono √® attivo o quando premi <kbd>üîä</kbd>.</div>
  </div>
</div>

<!-- pannello impostazioni -->
<aside id="panel" aria-modal="true" aria-hidden="true">
  <div class="panelTitle">
    <h3>Impostazioni di Luna</h3>
    <button id="closePanel" class="iconbtn">‚úñÔ∏è</button>
  </div>
  <div class="grid">
    <fieldset>
      <legend>Identit√†</legend>
      <label>Nome assistente</label>
      <div class="row">
        <input id="nameInput" class="mini" type="text" placeholder="Luna" />
        <button class="iconbtn" id="nameApply" title="Applica">‚úÖ</button>
      </div>
      <div class="small">Comando vocale rapido: ‚Äúcambia nome in ‚Ä¶‚Äù.</div>
    </fieldset>

    <fieldset>
      <legend>Voce</legend>
      <label>Seleziona voce (preferita: Federica)</label>
      <select id="voiceSelect"></select>
      <label>Velocit√†</label><input id="rate" type="range" min="0.6" max="1.2" step="0.01">
      <label>Tono</label><input id="pitch" type="range" min="0.8" max="1.2" step="0.01">
      <div class="small">Profilo consigliato Federica: velocit√† 0.96 ‚Ä¢ tono 1.04.</div>
      <hr class="sep">
      <div class="switch"><input type="checkbox" id="speakOnlyWhenMic"><label for="speakOnlyWhenMic">Parla solo con microfono attivo</label></div>
    </fieldset>

    <fieldset>
      <legend>Tema</legend>
      <div class="themeRow" id="themeRow">
        <button data-theme="dark" class="active">Scuro</button>
        <button data-theme="light">Chiaro</button>
        <button data-theme="midnight">Notte blu</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Avanzate</legend>
      <div class="small">Provider: <b id="providerInfo">Locale (browser)</b>. Futuri agganci: cloud/locale.</div>
      <div class="switch"><input type="checkbox" id="confirmBeforeSpeak"><label for="confirmBeforeSpeak">Conferma lettura quando non √® stato premuto il microfono</label></div>
      <button id="resetBtn">Ripristina impostazioni</button>
    </fieldset>
  </div>
</aside>

<script>
/* ============ util ============ */
const $ = s => document.querySelector(s);
const chat = $("#chat"), input = $("#input");
function addMsg(text, who='ai'){
  const div=document.createElement('div');
  div.className='msg '+(who==='me'?'me':'ai');
  div.innerHTML = text;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
  return div;
}
function setBadge(state){ $("#micText").textContent=state; }
function setDot(live){ $("#micDot").classList.toggle('live', !!live); }
function clamp(n,min,max){ return Math.max(min,Math.min(max,n)); }

/* ============ settings & memory ============ */
const store = {
  get(){ try{return JSON.parse(localStorage.getItem('luna-settings')||'{}')}catch(_){return {}} },
  set(v){ localStorage.setItem('luna-settings', JSON.stringify(v)); }
};
const S = Object.assign({
  name:'Luna', speakOnlyWhenMic:true, confirmBeforeSpeak:true,
  rate:0.96, pitch:1.04, voiceName:'Federica', theme:'dark'
}, store.get());

function applyTheme(theme){
  const t = theme || S.theme;
  if(t==='light'){
    document.documentElement.style.setProperty('--bg1','#f6f9ff');
    document.documentElement.style.setProperty('--bg2','#e7edff');
    document.documentElement.style.setProperty('--surface','#ffffff');
    document.documentElement.style.setProperty('--bubble','#f2f5ff');
    document.documentElement.style.setProperty('--text','#0e1020');
    document.documentElement.style.setProperty('--muted','#4b5580');
  }else if(t==='midnight'){
    document.documentElement.style.setProperty('--bg1','#0a0b12');
    document.documentElement.style.setProperty('--bg2','#0f1430');
    document.documentElement.style.setProperty('--surface','#121735');
    document.documentElement.style.setProperty('--bubble','#1a2150');
    document.documentElement.style.setProperty('--text','#eaf0ff');
    document.documentElement.style.setProperty('--muted','#96a2d9');
  }else{ // dark (default)
    document.documentElement.style.cssText = '';
  }
}
applyTheme();

/* ============ name & panel ============ */
$("#assistantName").textContent = S.name; $("#who").textContent=S.name;
$("#settingsBtn").onclick=()=>$("#panel").classList.add('open');
$("#closePanel").onclick=()=>$("#panel").classList.remove('open');
$("#nameInput").value=S.name;
$("#nameApply").onclick=()=>{
  const v=$("#nameInput").value.trim()||'Luna';
  S.name=v; store.set(S);
  $("#assistantName").textContent=v; $("#who").textContent=v;
  addMsg(`Nome aggiornato in <b>${v}</b>.`);
};
$("#themeRow").addEventListener('click',e=>{
  if(e.target.tagName!=='BUTTON')return;
  [...e.currentTarget.children].forEach(b=>b.classList.remove('active'));
  e.target.classList.add('active');
  S.theme=e.target.dataset.theme; store.set(S); applyTheme();
});

/* ============ voices (TTS) ============ */
const voiceSelect=$("#voiceSelect"); const ttsBtn=$("#ttsBtn");
let voices=[]; let selectedVoice=null;
function loadVoices(){
  voices = speechSynthesis.getVoices().filter(v=>v.lang.startsWith('it'));
  // preferisci Federica
  let preferred = voices.find(v=>/federica/i.test(v.name)) || voices[0];
  voiceSelect.innerHTML = '';
  // Mostra solo poche voci curate, Federica in cima
  const curated = [];
  if(preferred) curated.push(preferred);
  voices.forEach(v=>{ if(!curated.find(x=>x.name===v.name) && curated.length<3) curated.push(v); });
  curated.forEach(v=>{
    const opt=document.createElement('option');
    opt.value=v.name; opt.textContent=v.name + (v.default?' (predefinita)':'');
    voiceSelect.appendChild(opt);
  });
  // selezione iniziale
  const byName = curated.find(v=>v.name.includes(S.voiceName)) || preferred || curated[0];
  if(byName){ voiceSelect.value = byName.name; selectedVoice=byName; }
}
window.speechSynthesis.onvoiceschanged = loadVoices; loadVoices();

voiceSelect.onchange=()=>{ selectedVoice = speechSynthesis.getVoices().find(v=>v.name===voiceSelect.value); S.voiceName=selectedVoice?.name||S.voiceName; store.set(S); };
$("#rate").value=S.rate; $("#pitch").value=S.pitch;
$("#rate").oninput=e=>{ S.rate=+e.target.value; store.set(S); };
$("#pitch").oninput=e=>{ S.pitch=+e.target.value; store.set(S); };
$("#speakOnlyWhenMic").checked=S.speakOnlyWhenMic;
$("#speakOnlyWhenMic").onchange=e=>{ S.speakOnlyWhenMic=e.target.checked; store.set(S); };
$("#confirmBeforeSpeak").checked=S.confirmBeforeSpeak;
$("#confirmBeforeSpeak").onchange=e=>{ S.confirmBeforeSpeak=e.target.checked; store.set(S); };

$("#resetBtn").onclick=()=>{
  localStorage.removeItem('luna-settings'); location.reload();
};

/* ============ speak helper ============ */
function speak(text){
  if(!text) return;
  const u = new SpeechSynthesisUtterance(text);
  u.voice = selectedVoice || speechSynthesis.getVoices().find(v=>/federica/i.test(v.name));
  u.lang = 'it-IT';
  u.rate = S.rate; u.pitch = S.pitch;
  speechSynthesis.cancel(); speechSynthesis.speak(u);
}

/* ============ simple NLU ============ */
function replyTo(input){
  const t = input.toLowerCase().trim();

  // saluti/mi senti
  if(/(ciao|buongiorno|buonasera)/.test(t)) return "Ciao! Tutto bene, sono qui. Come posso aiutarti?";
  if(/(mi senti|sei li|ci sei)/.test(t)) return "S√¨, ti sento. Dimmi pure.";
  if(/come stai/.test(t)) return "Sto bene, grazie! Pronta a darti una mano.";

  // impostazioni rapide
  const m = t.match(/cambia nome in (.+)$/i); if(m){ const newName=m[1].trim(); $("#nameInput").value=newName; $("#nameApply").click(); return `Ok, da ora mi chiamo ${newName}.`; }
  if(/voce femminile/.test(t)) { // gi√† federica, conferma
    return "Uso la voce femminile. Se vuoi posso parlare un po‚Äô pi√π dolce o pi√π energica.";
  }
  if(/apri impostazioni/.test(t)) { $("#panel").classList.add('open'); return "Apro le impostazioni."; }
  if(/chiudi impostazioni/.test(t)) { $("#panel").classList.remove('open'); return "Chiuso."; }
  if(/(tema|colore).*(scuro)/.test(t)){ S.theme='dark'; store.set(S); applyTheme(); return "Imposto il tema scuro."; }
  if(/(tema|colore).*(chiaro)/.test(t)){ S.theme='light'; store.set(S); applyTheme(); return "Imposto il tema chiaro."; }

  // fallback
  return "Ricevuto. Vuoi che faccia qualcosa in particolare?";
}

/* ============ STT (microfono) ============ */
const speakBtn=$("#speakBtn"); const vu=$("#vu"); const modeHint=$("#modeHint");
let rec=null, listening=false, meterInt=null;
function supportedSTT(){ return ('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window); }

function startMic(){
  if(listening) return;
  if(!supportedSTT()){ addMsg("Il riconoscimento vocale non √® supportato da questo browser.",'ai'); return; }
  const R = window.SpeechRecognition || window.webkitSpeechRecognition;
  rec = new R(); rec.lang='it-IT'; rec.interimResults=true; rec.continuous=false;
  let buffer='';

  rec.onstart=()=>{ listening=true; setBadge('Ascolto'); setDot(true); modeHint.textContent='Voce'; animateMeter(); };
  rec.onresult=e=>{
    let final='';
    for(let i=e.resultIndex;i<e.results.length;i++){
      const res=e.results[i];
      if(res.isFinal){ final += res[0].transcript; }
      else { buffer = res[0].transcript; }
    }
    if(final){
      stopMeter();
      setDot(false); setBadge('Elaboro‚Ä¶');
      addMsg(final,'me');
      const out = replyTo(final);
      const node = addMsg(out,'ai');
      if(!S.speakOnlyWhenMic || (S.speakOnlyWhenMic && listening)) speak(out);
      setBadge('Pronta');
    }
  };
  rec.onerror=e=>{ stopMeter(); setDot(false); setBadge('Errore microfono'); console.warn(e); };
  rec.onend=()=>{ listening=false; stopMeter(); setDot(false); setBadge('Pronta'); };

  rec.start();
}
function stopMic(){ if(rec){ try{rec.stop();}catch(_){}} }
function animateMeter(){
  stopMeter();
  meterInt=setInterval(()=>{ const w = Math.floor(Math.random()*70)+10; vu.style.width=w+'%'; }, 80);
}
function stopMeter(){ if(meterInt){ clearInterval(meterInt); meterInt=null; } vu.style.width='0%'; }

speakBtn.onclick=()=>{
  if(listening){ stopMic(); }
  else { startMic(); }
}

/* ============ send text ============ */
$("#sendBtn").onclick=sendText;
input.addEventListener('keydown',e=>{ if(e.key==='Enter'){ sendText(); }});
function sendText(){
  const v = input.value.trim(); if(!v) return;
  addMsg(v, 'me'); input.value='';
  const out = replyTo(v);
  const node = addMsg(out,'ai');
  if(!S.speakOnlyWhenMic){
    if(S.confirmBeforeSpeak){ /* solo su richiesta esplicita */
      // non parlare automaticamente
    } else { speak(out); }
  }
}

/* ============ read last ============ */
ttsBtn.onclick=()=>{
  const last = [...document.querySelectorAll('.msg.ai')].pop();
  if(!last) return;
  speak(last.textContent.trim());
};

/* ============ initial UI ============ */
$("#providerState").textContent='Locale';
$("#providerInfo").textContent='Locale (Web Speech API)';
$("#modeHint").textContent = S.speakOnlyWhenMic ? 'Testo (voce con microfono)' : 'Testo+Voce';
setBadge('Pronta');
</script>
</body>
<script>
  // --- LUNA MOD MANAGER (da incollare una sola volta) ---
  window.Luna = window.Luna || {};
  Luna.mods = Luna.mods || {};
  Luna.api = Luna.api || {};

  Luna.registerMod = function(name, version, apply) {
    const cur = Luna.mods[name]?.version || "0.0.0";
    const newer = (a,b)=>a.split('.').map(Number).reduce((s,v,i)=>s||(v-(b.split('.')[i]|0)),0)>0;
    if (!Luna.mods[name] || newer(version, cur)) {
      try {
        const result = apply(Luna);
        Luna.mods[name] = { version, active:true, appliedAt: Date.now(), result };
        console.log(`[Luna] Mod "${name}" v${version} applicato (prima c'era v${cur||'‚Äî'})`);
      } catch(e) {
        console.error(`[Luna] Mod "${name}" errore:`, e);
      }
    } else {
      console.log(`[Luna] Mod "${name}" ignorato: v${version} ‚â§ v${cur}`);
    }
  };

  Luna.api.speak = Luna.api.speak || function(text){
    const u = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(u);
  };
  Luna.api.setTheme = Luna.api.setTheme || function(theme){
    document.documentElement.dataset.theme = theme;
  };
  <!-- SmartReplies v0.2 (IT) -->
<script>
(function () {
  // elenco intent semplici -> risposte naturali
  const intents = [
    { test: /(ciao|ehi|hey|buongiorno|buonasera)\b/i,
      reply: () => "Ciao! Eccomi qui üòä Come posso aiutarti?" },

    { test: /(come\s+stai|come ti senti)/i,
      reply: () => "Sto bene e pronta ad aiutarti! Vuoi provare qualcosa adesso?" },

    { test: /(apri|mostra).*(impostazioni|settaggi|rotellina)/i,
      reply: () => { try { document.getElementById('settingsBtn').click(); } catch(e){} 
                     return "Apro le impostazioni. Dimmi pure cosa vuoi cambiare."; } },

    { test: /(cambia|imposta).*(nome)/i,
      reply: () => "Ok! Dimmi: \"cambia nome in ...\" e lo aggiorno subito." },

    { test: /(voce|parla).*(femminile|maschile)/i,
      reply: () => "Posso cambiare voce dalle impostazioni. Vuoi che le apra?" },

    { test: /(tema|colore).*(scuro|dark|notte)/i,
      reply: () => "Imposto un tema scuro elegante. Vuoi provarlo ora?" },

    { test: /(tema|colore).*(chiaro|light|bianco)/i,
      reply: () => "Va bene, passo al tema chiaro. Dimmi se preferisci testo pi√π marcato." },

    { test: /(microfono|ascolta|ascolto)/i,
      reply: () => "Quando premi il microfono ti ascolto e rispondo a voce; se scrivi, rispondo in chat." },

    { test: /(grazie|perfetto|ok|va bene)\b/i,
      reply: () => "Di nulla! Se vuoi, posso cambiare voce, nome o tema." },
  ];

  function smartReply(input) {
    const msg = String(input || "").trim();
    if (!msg) return "Dimmi pure üòä";
    for (const it of intents) {
      if (it.test.test(msg)) return it.reply();
    }
    // fallback: niente ‚Äúpappagallo‚Äù
    return "Ricevuto! Posso cambiare voce, nome, tema o ascoltarti al microfono. Dimmi tu.";
  }

  // Hook: se esiste replyTo lo avvolgo, altrimenti uso smartReply
  const oldReply = window.replyTo;
  window.replyTo = function (input) {
    try { return smartReply(input); }
    catch (e) { return oldReply ? oldReply(input) : "Ok!"; }
  };
})();
<script>
// --- Preferenze voce iOS/Safari ---
<script>
(function(){
  // Candidati possibili per Federica premium/qualit√† elevata su iOS
  const CANDIDATES = [
    'Federica (premium)',
    'Federica (qualit√† elevata)',
    'Federica (enhanced)',
    'Federica'
  ];

  function awaitVoices() {
    return new Promise(resolve => {
      const list = speechSynthesis.getVoices();
      if (list && list.length) return resolve(list);
      speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
      // fallback se onvoiceschanged non parte
      setTimeout(() => resolve(speechSynthesis.getVoices()), 2000);
    });
  }

  async function pickItalianVoice() {
    const voices = await awaitVoices();

    // 1) prova Federica (nome)
    let v = voices.find(x =>
      x.lang === 'it-IT' &&
      x.name &&
      CANDIDATES.some(c => x.name.toLowerCase().includes(c.toLowerCase()))
    );
    // 2) prova Federica (voiceURI)
    if (!v) {
      v = voices.find(x => /Federica/i.test((x.voiceURI || '') + ' ' + (x.name || '')));
    }
    // 3) prova voce femminile it-IT
    if (!v) {
      v = voices.find(x => x.lang === 'it-IT' && /female|donna/i.test((x.name||'') + ' ' + (x.voiceURI||'')));
    }
    // 4) ultima spiaggia: qualunque it-IT
    if (!v) {
      v = voices.find(x => x.lang === 'it-IT');
    }
    return v || null;
  }

  // Patch del TTS di Luna: usa sempre la voce migliore trovata
  const oldSpeak = window.Luna?.api?.speak;
  if (oldSpeak) {
    window.Luna.api.speak = async function(text){
      if (!text) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang  = 'it-IT';
      utter.rate  = 0.96;  // velocit√† consigliata
      utter.pitch = 1.04;  // tono consigliato

      const v = await pickItalianVoice();
      if (v) utter.voice = v;

      speechSynthesis.cancel();
      speechSynthesis.speak(utter);
    };
  }
})();
<script>
(function(){
  const CANDIDATES = [
    'Federica (premium)',
    'Federica (qualit√† elevata)',
    'Federica (enhanced)',
    'Federica'
  ];

  function awaitVoices() {
    return new Promise(resolve => {
      const list = speechSynthesis.getVoices();
      if (list && list.length) return resolve(list);
      speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
      setTimeout(() => resolve(speechSynthesis.getVoices()), 2000);
    });
  }

  async function pickItalianVoice() {
    const voices = await awaitVoices();
    let v = voices.find(x =>
      x.lang === 'it-IT' &&
      x.name &&
      CANDIDATES.some(c => x.name.toLowerCase().includes(c.toLowerCase()))
    );
    if (!v) {
      v = voices.find(x => /Federica/i.test((x.voiceURI || '') + ' ' + (x.name || '')));
    }
    if (!v) {
      v = voices.find(x => x.lang === 'it-IT' && /female|donna/i.test((x.name||'') + ' ' + (x.voiceURI||'')));
    }
    if (!v) {
      v = voices.find(x => x.lang === 'it-IT');
    }
    return v || null;
  }
<script>
(function(){
  const CANDIDATES = [
    'Federica (premium)',
    'Federica (qualit√† elevata)',
    'Federica (enhanced)',
    'Federica'
  ];

  function awaitVoices() {
    return new Promise(resolve => {
      const list = speechSynthesis.getVoices();
      if (list && list.length) return resolve(list);
      speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
      setTimeout(() => resolve(speechSynthesis.getVoices()), 2000);
    });
  }

  async function pickItalianVoice() {
    const voices = await awaitVoices();
    let v = voices.find(x =>
      x.lang === 'it-IT' &&
      x.name &&
      CANDIDATES.some(c => x.name.toLowerCase().includes(c.toLowerCase()))
    );
    if (!v) {
      v = voices.find(x => /Federica/i.test((x.voiceURI || '') + ' ' + (x.name || '')));
    }
    if (!v) {
      v = voices.find(x => x.lang === 'it-IT' && /female|donna/i.test((x.name||'') + ' ' + (x.voiceURI||'')));
    }
    if (!v) {
      v = voices.find(x => x.lang === 'it-IT');
    }
    return v || null;
  }

  const oldSpeak = window.Luna?.api?.speak;
  if (oldSpeak) {
    window.Luna.api.speak = async function(text){
      if (!text) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang  = 'it-IT';
      utter.rate  = 0.96;
      utter.pitch = 1.04;

      const v = await pickItalianVoice();
      if (v) utter.voice = v;

      speechSynthesis.cancel();
      speechSynthesis.speak(utter);
    };
  }
})();
(async () => {
  async function pickItalianVoice() {
    const voices = await new Promise(resolve => {
      let v = speechSynthesis.getVoices();
      if (v.length) return resolve(v);
      speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
    });

    // cerca Federica o una voce femminile italiana HQ
    let v = voices.find(x =>
      x.lang === 'it-IT' &&
      x.name.toLowerCase().includes('federica')
    );

    if (!v) {
      v = voices.find(x => x.lang === 'it-IT' && /female|donna|it/i.test(x.name));
    }

    return v || null;
  }

  const oldSpeak = window.Luna?.api?.speak;
  if (oldSpeak) {
    window.Luna.api.speak = async (text) => {
      if (!text) return;

      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = 'it-IT';
      utter.rate = 0.96;   // velocit√†
      utter.pitch = 1.04;  // tono

      const v = await pickItalianVoice();
      if (v) utter.voice = v;

      speechSynthesis.cancel();
      speechSynthesis.speak(utter);
    };
  }
})()
<script>
/* ========== Modulo Voce Luna (forza femminile IT, preferenza Federica premium) ========== */
(function () {
  /* ---- nomi candidati ‚ÄúFederica‚Äù in iOS (varianti) ---- */
  const PREFERRED_NAMES = [
    'Federica', 'Federica (enhanced)', 'Federica (premium)', 'Federica (qualit√† elevata)'
  ];
  /* ---- altri possibili nomi femminili IT (fallback) ---- */
  const FEMALE_HINTS = [
    'alice','bianca','chiara','giulia','ilaria','isabella','lucia','martina','sara','sofia','valentina'
  ];

  const isIt = v => v && v.lang && v.lang.toLowerCase().startsWith('it');
  const hasName = (v, list) => list.some(n => (v.name || '').toLowerCase().includes(n.toLowerCase()));

  /* Safari carica le voci in ritardo: attendi con polling breve */
  function waitForVoices() {
    return new Promise(resolve => {
      let tries = 0;
      const tick = () => {
        const list = speechSynthesis.getVoices();
        if (list && list.length) return resolve(list);
        if (++tries > 20) return resolve(list); // ~3s massimo
        setTimeout(tick, 150);
      };
      /* attiva anche l‚Äôevento se esiste */
      if ('onvoiceschanged' in speechSynthesis) {
        speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
      }
      tick();
    });
  }

  async function pickItalianFemale() {
    const list = await waitForVoices();
    if (!list || !list.length) return null;

    // 1) prova Federica (premium/enhanced)
    let v = list.find(x => isIt(x) && hasName(x, PREFERRED_NAMES));
    // 2) altrimenti qualunque nome femminile noto
    if (!v) v = list.find(x => isIt(x) && hasName(x, FEMALE_HINTS));
    // 3) fallback: qualunque voce italiana
    if (!v) v = list.find(isIt);
    return v || null;
  }

  /* Sovrascrivi la sintesi di Luna per usare sempre la voce scelta qui */
  const oldSpeak = window.Luna?.api?.speak;
  if (oldSpeak) {
    window.Luna.api.speak = async function (text) {
      if (!text) return;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'it-IT';
      u.rate = 0.96;   // velocit√† consigliata
      u.pitch = 1.04;  // timbro leggermente pi√π alto

      const v = await pickItalianFemale();
      if (v) u.voice = v;

      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    };
  }

  /* ‚ÄúRipulisci‚Äù il men√π voci nell‚ÄôUI: rimuovi Eddy/Sandy/Reed e lascialo fisso */
  function rewriteVoiceMenu() {
    const selects = document.querySelectorAll('select');
    for (const s of selects) {
      const texts = [...s.options].map(o => (o.textContent||'').toLowerCase());
      // se contiene le voci predefinite maschili, sostituisci il men√π
      if (texts.some(t => t.startsWith('eddy')) || texts.some(t => t.startsWith('sandy')) || texts.some(t => t.startsWith('reed'))) {
        s.innerHTML = '';
        const opt = document.createElement('option');
        opt.value = 'federica-auto';
        opt.textContent = 'Federica (automatica)';
        s.appendChild(opt);
        s.disabled = true; // lo rendiamo non modificabile
        // suggerimento visivo (se c‚Äô√® una label vicino)
        const lbl = s.closest('div,section,fieldset')?.querySelector('label, .label, .title');
        if (lbl && lbl.textContent.toLowerCase().includes('seleziona voce')) {
          lbl.textContent = 'Voce (fissa): Federica';
        }
      }
    }
  }
  // applica subito e anche quando si aprono/impostazioni cambiano
  rewriteVoiceMenu();
  const obs = new MutationObserver(rewriteVoiceMenu);
  obs.observe(document.documentElement, { childList: true, subtree: true });
})();
<script>
// ====== ADAPTER AUDIO LUNA (nativo se disponibile, altrimenti web) ======
window.Luna = window.Luna || {};
Luna.audio = Luna.audio || {};

// Rileva bridge nativo (WKWebView)
const _hasNative = !!(window.webkit && window.webkit.messageHandlers && (
  window.webkit.messageHandlers.lunaTTS || window.webkit.messageHandlers.lunaASR
));

// Espone helper per postMessage sicuro
function _nativePost(handler, payload) {
  try { window.webkit.messageHandlers[handler].postMessage(payload); }
  catch(e){ console.warn('Bridge native non disponibile:', handler, e); }
}

// ---- SPEAK: preferisci nativo, fallback web ----
Luna.audio.speak = async function(text, opts = {}) {
  if (!text) return;

  // preferisci nativo se presente
  if (_hasNative && window.webkit.messageHandlers.lunaTTS) {
    _nativePost('lunaTTS', {
      text,
      lang: opts.lang || 'it-IT',
      rate: opts.rate ?? 0.96,
      pitch: opts.pitch ?? 1.04,
      voiceHint: opts.voiceHint || 'Federica',   // suggerimento
      category: 'playback'
    });
    return;
  }

  // ---- Fallback web (usa la tua funzione di pick/voice gi√† presente) ----
  try {
    const u = new SpeechSynthesisUtterance(text);
    u.lang  = opts.lang  || 'it-IT';
    u.rate  = opts.rate  ?? 0.96;
    u.pitch = opts.pitch ?? 1.04;

    // prova a prendere una voce italiana (Federica se disponibile)
    const voices = speechSynthesis.getVoices();
    let v = voices.find(x => x.lang === 'it-IT' && /federica/i.test(x.name));
    if (!v) v = voices.find(x => x.lang === 'it-IT');
    if (v) u.voice = v;

    speechSynthesis.cancel();
    speechSynthesis.speak(u);
  } catch(e) {
    console.warn('Fallback TTS web errore:', e);
  }
};

// ---- SESSIONE MICROFONO (richiede nativo per affidabilit√† continua) ----
Luna.audio.startListening = function () {
  if (_hasNative && window.webkit.messageHandlers.lunaASR) {
    _nativePost('lunaASR', { cmd: 'start', lang: 'it-IT', continuous: true, vad: true });
  } else {
    // Fallback web: iOS Safari non √® stabile in continuo
    alert('Per conversazione continua serve l‚Äôapp nativa. Sul web la dettatura pu√≤ fermarsi.');
  }
};

Luna.audio.stopListening = function () {
  if (_hasNative && window.webkit.messageHandlers.lunaASR) {
    _nativePost('lunaASR', { cmd: 'stop' });
  } else {
    // niente da fare lato web
  }
};

// Ricezione trascrizioni dal nativo (Swift -> JS)
window.onLunaASR = function (result) {
  // result: { text, isFinal, timestamp }
  // qui decidi cosa fare quando arrivano parole/frasi
  // Esempio: invia quando isFinal √® true
  if (result?.isFinal && result.text) {
    // usa la tua funzione esistente per inviare il messaggio
    if (window.sendUserText) window.sendUserText(result.text);
  }
};

// Pulsante rapido test voce (opzionale)
if (!document.getElementById('testVoiceBtn')) {
  const b = document.createElement('button');
  b.id = 'testVoiceBtn';
  b.textContent = 'üîä Prova voce';
  b.style.cssText = 'position:fixed;right:.75rem;bottom:.75rem;z-index:999;';
  b.onclick = ()=> Luna.audio.speak('Ciao! Questa √® una prova voce.');
  document.body.appendChild(b);
}
import AVFoundation

class LunaTTS: NSObject {
  private let synth = AVSpeechSynthesizer()

  func speak(_ payload: [String: Any]) {
    guard let text = payload["text"] as? String, !text.isEmpty else { return }
    let rate  = (payload["rate"]  as? Double) ?? 0.96
    let pitch = (payload["pitch"] as? Double) ?? 1.04
    let lang  = (payload["lang"]  as? String) ?? "it-IT"
    let hint  = (payload["voiceHint"] as? String)?.lowercased() ?? "federica"

    let uttr = AVSpeechUtterance(string: text)
    uttr.voice = pickVoice(lang: lang, hint: hint)   // Federica premium se presente
    uttr.rate  = AVSpeechUtteranceDefaultSpeechRate * Float(rate)
    uttr.pitchMultiplier = Float(pitch)

    try? AVAudioSession.sharedInstance().setCategory(.playback, mode: .spokenAudio, options: [.duckOthers])
    try? AVAudioSession.sharedInstance().setActive(true, options: .notifyOthersOnDeactivation)
    synth.stopSpeaking(at: .immediate)
    synth.speak(uttr)
  }

  private func pickVoice(lang: String, hint: String) -> AVSpeechSynthesisVoice? {
    let all = AVSpeechSynthesisVoice.speechVoices().filter { $0.language == lang }
    // premium se disponibile
    if #available(iOS 16.0, *) {
      if let v = all.first(where: { $0.name.lowercased().contains(hint) && $0.quality == .premium }) { return v }
    }
    if let v = all.first(where: { $0.name.lowercased().contains(hint) }) { return v }
    return all.first
  }
}
import Speech
import AVFoundation
import WebKit

class LunaASR: NSObject {
  private let recognizer = SFSpeechRecognizer(locale: Locale(identifier: "it_IT"))
  private let audioEngine = AVAudioEngine()
  private var request: SFSpeechAudioBufferRecognitionRequest?
  private var task: SFSpeechRecognitionTask?
  weak var webView: WKWebView?

  func start() {
    SFSpeechRecognizer.requestAuthorization { status in
      guard status == .authorized else { return }
      DispatchQueue.main.async { self.beginSession() }
    }
  }

  func stop() {
    task?.cancel(); task = nil
    audioEngine.stop()
    audioEngine.inputNode.removeTap(onBus: 0)
  }

  private func beginSession() {
    stop()
    try? AVAudioSession.sharedInstance().setCategory(.record, mode: .measurement, options: .duckOthers)
    try? AVAudioSession.sharedInstance().setActive(true, options: .notifyOthersOnDeactivation)

    request = SFSpeechAudioBufferRecognitionRequest()
    request?.shouldReportPartialResults = true

    let input = audioEngine.inputNode
    let fmt = input.outputFormat(forBus: 0)
    input.installTap(onBus: 0, bufferSize: 1024, format: fmt) { buffer, _ in
      self.request?.append(buffer)
    }
    audioEngine.prepare()
    try? audioEngine.start()

    task = recognizer?.recognitionTask(with: request!) { result, error in
      guard let result = result else { return }
      let js = """
      window.onLunaASR && window.onLunaASR({
        text: \(String(describing: result.bestTranscription.formattedString).debugDescription),
        isFinal: \(result.isFinal ? "true":"false"),
        timestamp: \(Date().timeIntervalSince1970)
      });
      """
      self.webView?.evaluateJavaScript(js, completionHandler: nil)
    }
  }
}
class Bridge: NSObject, WKScriptMessageHandler {
  let tts = LunaTTS()
  let asr = LunaASR()

  func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
    if message.name == "lunaTTS", let p = message.body as? [String: Any] { tts.speak(p) }
    if message.name == "lunaASR", let p = message.body as? [String: Any] {
      if (p["cmd"] as? String) == "start" { asr.start() } else { asr.stop() }
    }
  }
}
let bridge = Bridge()
let ucc = webView.configuration.userContentController
ucc.add(bridge, name: "lunaTTS")
ucc.add(bridge, name: "lunaASR")
bridge.asr.webView = webView
document.body.appendChild(b);
}

// <<--- QUI INCOLLA IL NUOVO BLOCCO "PULSANTE CHIAMATA" --->

// Pulsante per chiamata vocale continua
if (!document.getElementById('callBtn')) {
  const c = document.createElement('button');
  c.id = 'callBtn';
  c.textContent = 'üìû Avvia chiamata';
  c.style.cssText = 'position:fixed;left:.75rem;bottom:.75rem;z-index:999;';
  let active = false;

  c.onclick = () => {
    if (!active) {
      Luna.audio.startListening();
      c.textContent = 'üî¥ Chiudi chiamata';
      active = true;
    } else {
      Luna.audio.stopListening();
      c.textContent = 'üìû Avvia chiamata';
      active = false;
    }
  };

  document.body.appendChild(c);
  <script>
/* =========================================
   LUNA: Voce unica femminile + chiamata continua
   (auto-override, auto-hide vecchio menu voci)
   ========================================= */
(function () {
  // ------- 1) Utility DOM -------
  function hideVoiceSelectCompletely() {
    // prova a trovare un <select> che contiene Eddy/Sandy/Reed
    const selects = Array.from(document.querySelectorAll('select, .select, [role="listbox"]'));
    const isVoiceSelect = (el) => {
      const txt = el.innerText + ' ' + (el.value || '');
      return /Eddy|Sandy|Reed/i.test(txt);
    };
    const voiceSel = selects.find(isVoiceSelect);
    if (voiceSel) {
      // nasconde il contenitore pi√π ampio (riga impostazioni)
      let row = voiceSel.closest('[class*="row"], [class*="group"], .setting, .form-group, .field') || voiceSel.parentElement;
      if (row) row.style.display = 'none';
    }
    // Etichetta informativa (opzionale)
    if (!document.getElementById('luna-voice-badge')) {
      const badge = document.createElement('div');
      badge.id = 'luna-voice-badge';
      badge.textContent = 'Voce: femminile (forzata)';
      badge.style.cssText = 'margin-top:.5rem;opacity:.7;font-size:.9rem;';
      // infilalo nella sezione "Voce" se esiste
      const voiceSection = Array.from(document.querySelectorAll('h3,h2,legend,label'))
        .find(x => /voce/i.test(x.textContent));
      (voiceSection && voiceSection.parentElement || document.body).appendChild(badge);
    }
  }

  // esegui hide appena pronto il DOM, e anche dopo piccole attese (UI dinamica)
  const ob = new MutationObserver(hideVoiceSelectCompletely);
  ob.observe(document.documentElement, {subtree:true, childList:true});
  if (document.readyState !== 'loading') hideVoiceSelectCompletely();
  else document.addEventListener('DOMContentLoaded', hideVoiceSelectCompletely);

  // ------- 2) Forza VOCE FEMMINILE (Web Speech, lato browser) -------
  // Nota: su Safari iOS spesso compaiono solo 2-3 voci. Qui scegliamo comunque
  // la migliore femminile disponibile (preferendo "Sandy" o nomi femminili).
  const FEMALE_HINTS = ['sandy','federica','alice','giulia','carla','elena','sofia','female','donna','femmina'];

  function waitForVoices() {
    return new Promise((resolve) => {
      const have = speechSynthesis.getVoices();
      if (have && have.length) return resolve(have);
      speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
      // in Safari l‚Äôevento a volte non arriva: fallback
      setTimeout(() => resolve(speechSynthesis.getVoices() || []), 800);
    });
  }

  async function pickFemaleItalianVoice() {
    const voices = await waitForVoices();
    // 1) filtra it-IT
    let it = voices.filter(v => /it[-_]?IT/i.test(v.lang || ''));
    // 2) preferisci nomi femminili
    let fem = it.find(v => FEMALE_HINTS.some(h => (v.name||'').toLowerCase().includes(h)));
    // 3) se non trovata, prova "Sandy" (di solito femminile)
    if (!fem) fem = voices.find(v => /sandy/i.test(v.name||''));
    // 4) senn√≤ prendi la prima it-IT, altrimenti la prima disponibile
    return fem || it[0] || voices[0] || null;
  }

  // ------- 3) Override TTS (sostituisce qualunque speak esistente) -------
  const oldApi = (window.Luna && window.Luna.api) || {};
  window.Luna = window.Luna || {};
  window.Luna.api = {...oldApi};

  window.Luna.api.speak = async function (text) {
    try {
      if (!text) return;
      const v = await pickFemaleItalianVoice();
      const u = new SpeechSynthesisUtterance(text);
      u.lang  = (v && v.lang) || 'it-IT';
      u.voice = v || null;
      u.rate  = 0.96;
      u.pitch = 1.04;
      // stop prima di parlare
      try { speechSynthesis.cancel(); } catch {}
      speechSynthesis.speak(u);
    } catch (e) {
      console.warn('TTS fallback error:', e);
    }
  };

  // ------- 4) ‚ÄúChiamata‚Äù continua (ASR con riavvio automatico) -------
  // Funziona dove c‚Äô√® webkitSpeechRecognition (Safari iOS ha supporto parziale).
  // Resta in ascolto e si riavvia da sola dopo ogni end, finch√© non chiami stopCall().
  let rec = null;
  let recWanted = false;

  function createRecognizer() {
    const R = new (window.webkitSpeechRecognition || window.SpeechRecognition)();
    R.lang = 'it-IT';
    R.interimResults = true;
    R.continuous = true; // Safari spesso lo ignora, ma la riavviamo noi
    R.onresult = (ev) => {
      const last = ev.results[ev.results.length - 1];
      if (!last) return;
      const txt = last[0] && last[0].transcript || '';
      const isFinal = !!last.isFinal;

      // Mostra in UI (se hai una funzione per aggiornare input live)
      if (window.onPartialTranscript && !isFinal) window.onPartialTranscript(txt);

      if (isFinal) {
        // Invia al motore di risposta
        if (window.sendUserText) window.sendUserText(txt);
      }
    };
    R.onerror = (e) => {
      // piccoli errori sono normali su iOS; tentiamo il riavvio se la chiamata √® attiva
      setTimeout(() => { if (recWanted) safeStart(); }, 350);
    };
    R.onend = () => {
      if (recWanted) setTimeout(() => safeStart(), 250);
    };
    return R;
  }

  function safeStart() {
    try {
      if (!rec) rec = createRecognizer();
      rec.start();
    } catch (e) {
      // se "already started", ignoriamo; altrimenti riproviamo
      if (String(e).toLowerCase().includes('started')) return;
      setTimeout(safeStart, 300);
    }
  }

  async function startCall() {
    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      alert('Il riconoscimento vocale continuo non √® supportato su questo browser.');
      return;
    }
    recWanted = true;
    safeStart();
    showCallUI(true);
  }

  function stopCall() {
    recWanted = false;
    try { rec && rec.stop(); } catch {}
    showCallUI(false);
  }

  // ------- 5) Piccola UI: pulsanti ‚ÄúAvvia/Chiudi chiamata‚Äù -------
  function showCallUI(active) {
    let bar = document.getElementById('luna-callbar');
    if (!bar) {
      bar = document.createElement('div');
      bar.id = 'luna-callbar';
      bar.style.cssText =
        'position:fixed;right:14px;bottom:14px;display:flex;gap:8px;z-index:99999';
      const btnStart = document.createElement('button');
      btnStart.id = 'luna-call-start';
      btnStart.textContent = 'üìû Avvia chiamata';
      const btnStop  = document.createElement('button');
      btnStop.id = 'luna-call-stop';
      btnStop.textContent  = 'üõë Chiudi chiamata';
      [btnStart, btnStop].forEach(b=>{
        b.style.cssText = 'padding:.6rem .8rem;border-radius:.7rem;border:0;cursor:pointer';
        b.style.background = 'var(--btn-bg, #2b6)';
        b.style.color = '#fff';
        b.onmouseenter = ()=> b.style.filter='brightness(0.95)';
        b.onmouseleave = ()=> b.style.filter='';
      });
      btnStart.onclick = startCall;
      btnStop.onclick  = stopCall;
      bar.appendChild(btnStart);
      bar.appendChild(btnStop);
      document.body.appendChild(bar);
    }
    const s = document.getElementById('luna-call-start');
    const t = document.getElementById('luna-call-stop');
    if (s && t) {
      s.style.display = active ? 'none' : 'inline-block';
      t.style.display = active ? 'inline-block' : 'none';
    }
  }

  // Se vuoi partire gi√† ‚Äúpronta per la chiamata‚Äù, lascia commentata:
  // startCall();

})();
<script>
(() => {
  // ---------- 1) Scelta forzata voce femminile italiana ----------
  const FEMALE_HINTS = /federica|alice|lucia|silvia|fem|female/i;

  function waitForVoices() {
    return new Promise(resolve => {
      const v = speechSynthesis.getVoices();
      if (v && v.length) return resolve(v);
      speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
    });
  }

  async function pickItalianFemale() {
    const voices = await waitForVoices();
    // A) femminile esplicito o nomi comuni
    let v = voices.find(x =>
      (x.lang || '').toLowerCase().startsWith('it') && FEMALE_HINTS.test(x.name)
    );
    // B) qualsiasi femminile italiano (alcuni browser mettono "female" in voiceURI)
    if (!v) v = voices.find(x =>
      (x.lang || '').toLowerCase().startsWith('it') &&
      /fem|female/i.test(`${x.name} ${x.voiceURI} ${x.localService}`)
    );
    // C) fallback: qualunque voce italiana
    if (!v) v = voices.find(x => (x.lang || '').toLowerCase().startsWith('it'));
    return v || null;
  }

  // Hook: rimpiazzo parlato di Luna con la voce scelta
  window.Luna = window.Luna || {};
  window.Luna.api = window.Luna.api || {};
  const oldSpeak = window.Luna.api.speak;

  window.Luna.api.speak = async function (text) {
    if (!text) return;
    try {
      const u = new SpeechSynthesisUtterance(text);
      const v = await pickItalianFemale();
      if (v) u.voice = v;
      u.lang = 'it-IT';
      u.rate = 0.96;
      u.pitch = 1.04;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    } catch (e) {
      // fallback al vecchio speak se esiste
      if (typeof oldSpeak === 'function') return oldSpeak(text);
      console.warn('TTS fallback:', e);
    }
  };

  // ---------- 2) Nascondi men√π voci (Eddy/Sandy/Reed) ----------
  const hideVoiceUI = () => {
    const cand = [
      document.querySelector('#voiceSelect'),
      document.querySelector('select[name="voice"]'),
      document.querySelector('select[name="voiceSelect"]')
    ].find(Boolean);
    const box = cand?.closest('.row, .setting, .card, div');
    (box || cand)?.style?.setProperty('display', 'none', 'important');
  };
  hideVoiceUI();

  // ---------- 3) Conversazione continua (start/stop) ----------
  try {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SR) {
      const rec = new SR();
      rec.lang = 'it-IT';
      rec.continuous = true;
      rec.interimResults = true;

      let active = false;
      let pausedForTTS = false;

      function start() {
        if (active) return;
        active = true;
        try { rec.start(); } catch {}
      }
      function stop() {
        active = false;
        try { rec.stop(); } catch {}
      }

      rec.onresult = (e) => {
        const r = e.results[e.results.length - 1];
        if (!r) return;
        if (r.isFinal) {
          const text = r[0].transcript.trim();
          // comandi per chiudere la ‚Äúchiamata‚Äù
          if (/(chiudi|termina|stoppa).*(chiamata|microfono)?/i.test(text)) {
            stop();
            return;
          }
          if (window.sendUserText) window.sendUserText(text);
        }
      };

      // se la sintesi parla, metti in pausa il riconoscimento
      const onTTSStart = () => { if (active) { pausedForTTS = true; try { rec.stop(); } catch {} } };
      const onTTSEnd   = () => { if (active || pausedForTTS) { pausedForTTS = false; start(); } };
      window.speechSynthesis.addEventListener('voiceschanged', ()=>{}); // no-op per inizializzare
      window.speechSynthesis.addEventListener('start', onTTSStart);
      window.speechSynthesis.addEventListener('end', onTTSEnd);

      rec.onend = () => { if (active && !speechSynthesis.speaking) start(); };

      // collega al pulsante microfono se esiste
      const micBtn = document.querySelector('#micBtn, [data-role="mic"], .mic-btn, button[title*="microfono"]');
      if (micBtn) {
        micBtn.onclick = () => (active ? stop() : start());
        micBtn.title = 'Tocca per avviare/fermare la conversazione continua';
      }
      // esponi API per eventuali comandi vocali/testo
      window.LunaVoice = { start, stop };
    }
  } catch (e) {
    console.warn('ASR continuous mode disabled:', e);
  }
})();
/* ===================== LUNA ‚Äî UNIFIED PATCH (v3) =====================
   - Voce femminile forzata (niente pi√π Eddy/Sandy/Reed visibili)
   - Conversazione continua (riavvio automatico del microfono)
   - PWA: manifest + service worker generati al volo (nessun file extra)
   - Pulsanti: üîä Prova voce & üìû Avvia/Chiudi chiamata
   ==================================================================== */
(() => {
  if (window.__LUNA_UNIFIED_PATCH__) return;
  window.__LUNA_UNIFIED_PATCH__ = true;

  // ---------- 0) BADGE VERSIONE ----------
  (function addVersionBadge(){
    const b = document.createElement('div');
    b.textContent = 'Luna Patch v3 attiva ‚úÖ';
    b.style.cssText = 'position:fixed;left:10px;top:10px;padding:6px 10px;border-radius:8px;background:#0b0d12;color:#fff;font:12px/1.2 system-ui;opacity:.8;z-index:99999';
    document.body.appendChild(b);
    setTimeout(()=>b.remove(), 3500);
  })();

  // ---------- 1) Nascondi select voci & preferenza femminile ----------
  function hideVoiceMenu() {
    const selects = [...document.querySelectorAll('select, [role="listbox"]')];
    const isVoiceSelect = sel => {
      const txt = (sel.innerText||'') + ' ' + (sel.value||'');
      return /Eddy|Sandy|Reed/i.test(txt) || /voce/i.test(txt);
    };
    const target = selects.find(isVoiceSelect);
    if (target) {
      const wrap = target.closest('.row,.setting,.field,.card,section,div') || target;
      wrap.style.display = 'none';
    }
  }
  new MutationObserver(hideVoiceMenu).observe(document.documentElement,{childList:true,subtree:true});
  hideVoiceMenu();
  localStorage.setItem('preferredVoice','federica');

  // ---------- 2) TTS: forza voce femminile italiana ----------
  const FEMALE_HINTS = /federica|alice|silvia|sofia|giulia|martina|valentina|female|donna|femmina/i;
  function waitForVoices() {
    return new Promise(res=>{
      const v = speechSynthesis.getVoices();
      if (v && v.length) return res(v);
      speechSynthesis.onvoiceschanged = () => res(speechSynthesis.getVoices());
      try { const u = new SpeechSynthesisUtterance(' '); speechSynthesis.speak(u); speechSynthesis.cancel(); } catch {}
      setTimeout(()=>res(speechSynthesis.getVoices()||[]), 1000);
    });
  }
  async function pickItalianFemale() {
    const voices = await waitForVoices();
    const it = voices.filter(v => (v.lang||'').toLowerCase().startsWith('it'));
    let v = it.find(v => FEMALE_HINTS.test((v.name||'')+' '+(v.voiceURI||'')));
    if (!v) v = it[0] || voices[0] || null;
    return v;
  }
  window.Luna = window.Luna || {}; window.Luna.api = window.Luna.api || {};
  const _oldSpeak = window.Luna.api.speak;
  window.Luna.api.speak = async function(text){
    if (!text) return;
    try{
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'it-IT'; u.rate = 0.96; u.pitch = 1.04;
      const v = await pickItalianFemale(); if (v) u.voice = v;
      try { speechSynthesis.cancel(); } catch {}
      speechSynthesis.speak(u);
    } catch(e){
      if (typeof _oldSpeak === 'function') return _oldSpeak(text);
    }
  };

  // ---------- 3) Conversazione continua (ASR con auto-restart) ----------
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  let rec = null, micOn = false, pausedForTTS = false, restartTimer = null;

  function ensureRecognizer(){
    if (rec) return rec;
    if (!SR) return null;
    rec = new SR();
    rec.lang = 'it-IT';
    rec.interimResults = true;
    rec.continuous = true;
    rec.onresult = (ev)=>{
      const last = ev.results[ev.results.length-1];
      if (!last) return;
      if (last.isFinal){
        const text = (last[0] && last[0].transcript || '').trim();
        if (!text) return;
        if (/(chiudi|termina|ferma).*(chiamata|microfono)?/i.test(text)) { stopCall(); window.Luna.api.speak('Chiamata chiusa.'); return; }
        if (typeof window.sendUserText === 'function') window.sendUserText(text);
      }
    };
    const restart = ()=>{
      if (!micOn) return;
      clearTimeout(restartTimer);
      restartTimer = setTimeout(()=>{ try{ rec.start(); }catch{} }, 200);
    };
    rec.onend = restart;
    rec.onerror = restart;
    try{
      speechSynthesis.addEventListener('start', ()=>{ if (micOn){ pausedForTTS = true; try{ rec.stop(); }catch{} }});
      speechSynthesis.addEventListener('end',   ()=>{ if (micOn && pausedForTTS){ pausedForTTS=false; restart(); }});
    }catch{}
    return rec;
  }

  function startCall(){
    const R = ensureRecognizer();
    if (!R){ alert('Riconoscimento vocale continuo non supportato in questo browser. Usa Safari/PWA.'); return; }
    if (micOn) return;
    micOn = true;
    try { R.start(); } catch {}
    showCallUI(true);
    window.Luna.api.speak('Sono in ascolto. Dimmi pure.');
  }
  function stopCall(){
    micOn = false;
    try { rec && rec.stop(); } catch {}
    showCallUI(false);
  }
  window.startCall = startCall;
  window.stopCall  = stopCall;

  // ---------- 4) UI: pulsanti prova voce & chiamata ----------
  function showCallUI(active){
    let bar = document.getElementById('luna-callbar');
    if (!bar){
      bar = document.createElement('div');
      bar.id = 'luna-callbar';
      bar.style.cssText = 'position:fixed;right:12px;bottom:12px;display:flex;gap:8px;z-index:99998';
      const btnStart = document.createElement('button');
      btnStart.id='luna-call-start'; btnStart.textContent='üìû Avvia chiamata';
      const btnStop  = document.createElement('button');
      btnStop.id='luna-call-stop';  btnStop.textContent='üõë Chiudi chiamata';
      [btnStart,btnStop].forEach(b=>{
        b.style.cssText='padding:.6rem .8rem;border:0;border-radius:10px;background:#2470ff;color:#fff;font:14px system-ui;cursor:pointer';
      });
      btnStart.onclick = startCall;
      btnStop.onclick  = stopCall;
      bar.append(btnStart, btnStop);
      document.body.appendChild(bar);
    }
    const s = document.getElementById('luna-call-start');
    const t = document.getElementById('luna-call-stop');
    if (s && t){ s.style.display = active?'none':'inline-block'; t.style.display = active?'inline-block':'none'; }
  }
  (function addTestButton(){
    if (document.getElementById('luna-voice-test')) return;
    const b = document.createElement('button');
    b.id='luna-voice-test'; b.textContent='üîä Prova voce';
    b.style.cssText='position:fixed;left:12px;bottom:12px;padding:.6rem .8rem;border:0;border-radius:10px;background:#18a957;color:#fff;font:14px system-ui;z-index:99998';
    b.onclick = ()=> window.Luna.api.speak('Ciao! Questa √® una prova voce.');
    document.body.appendChild(b);
  })();
  showCallUI(false);

  // ---------- 5) PWA: manifest + service worker (al volo) ----------
  (function setupPWA(){
    const manifest = {
      name: "Luna",
      short_name: "Luna",
      start_url: "./index.html?source=pwa",
      display: "standalone",
      orientation: "portrait",
      background_color: "#0b0d12",
      theme_color: "#0b0d12",
      icons: [
        { src: "data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 512 512%27><rect width=%27512%27 height=%27512%27 rx=%2796%27 fill=%27%230b0d12%27/><circle cx=%27256%27 cy=%27256%27 r=%27140%27 fill=%27%23ffffff%27/><circle cx=%27306%27 cy=%27226%27 r=%27140%27 fill=%27%230b0d12%27/></svg>", sizes: "192x192", type: "image/svg+xml" }
      ]
    };
    const blob = new Blob([JSON.stringify(manifest)], {type:'application/json'});
    const link = document.createElement('link'); link.rel='manifest'; link.href=URL.createObjectURL(blob);
    document.head.appendChild(link);

    const swCode = `
      const C='luna-pwa-v1';
      const ASSETS=['./','./index.html'];
      self.addEventListener('install',e=>{e.waitUntil(caches.open(C).then(c=>c.addAll(ASSETS)))});
      self.addEventListener('activate',e=>{e.waitUntil(caches.keys().then(keys=>Promise.all(keys.filter(k=>k!==C).map(k=>caches.delete(k)))))});
      self.addEventListener('fetch',e=>{
        const r=e.request;
        e.respondWith(
          caches.match(r).then(cached => cached || fetch(r).then(res=>{
            try{const copy=res.clone(); if(r.method==='GET'){caches.open(C).then(c=>c.put(r,copy))} }catch(e){}
            return res;
          }).catch(()=>cached))
        );
      });
    `;
    if ('serviceWorker' in navigator) {
      const swURL = URL.createObjectURL(new Blob([swCode], {type:'text/javascript'}));
      navigator.serviceWorker.register(swURL).catch(()=>{});
    }
    const meta1=document.createElement('meta'); meta1.name='apple-mobile-web-app-capable'; meta1.content='yes';
    const meta2=document.createElement('meta'); meta2.name='apple-mobile-web-app-status-bar-style'; meta2.content='black-translucent';
    document.head.append(meta1, meta2);
  })();

})();
</script>
<script src="./luna-patch-v3.js?v=1"></script>
</html>


  
  